return(dt)
}
clean_data(
data = youngSwimmers::youngswimmers,
x = period,
y = weight,
rowid = subject,
paired = TRUE
)
clean_data <- function(data, x, y, rowid,
paired = FALSE,
wide = FALSE,
character.only = FALSE,
...) {
# Argument checking ---------------------------------------------------------------------------
# Check if `data` is null
if (missing(data)) stop("`data` can't be null", call. = FALSE)
# Check if `x` or `y` is null
if (missing(x) || missing(y)) stop("`x` and `y` can't be null", call. = FALSE)
# If `character.only` == FALSE, then NSE is used ----------------------------------------------
x <- rlang::ensym(x); y <- rlang::ensym(y)
# Check if variables are present in data ------------------------------------------------------
# Get names
colum_names <- names(data)
# Otherwise, check if is in data
if (all(x != colum_names) || all(y != colum_names)) stop("`x` and `y` must be within your data. Check your arguments", call. = FALSE)
# For latter use
x_var <- data[[x]]
# Check if rowid is present in the data if is paired and not null
if (isTRUE(paired)) {
if (missing(rowid)) {
rowid_var <- data.table::rowidv(x_var)
} else {
rowid <- rlang::ensym(rowid)
rowid_var <- data[[rowid]]
}
} else if (isFALSE(paired)) {
rowid_var <- NULL
} else stop("`paired` must be TRUE or FALSE")
# Add rowid if paired is TRUE and drop unused levels
dt <- data.table::data.table(x_var, data[[y]], rowid_var)
data.table::setnames(dt, 1:3, c(x, y, "rowid"))
dt <- droplevels(x = stats::na.omit(dt))
return(dt)
# Get levels for input data and output data
data_x_levels <- levels(data[[x]])
dt_x_levels <- levels(dt[[x]])
# Check for empty levels
if (length(data_x_levels) > length(dt_x_levels)) {
drlv <- data_x_levels[!data_x_levels %in% dt_x_levels]
# Display a warning if any
warning(
"Unused levels (i.e. ",
paste0(drlv, collapse = ", "),
") were dropped",
call. = FALSE
)
}
if (isTRUE(paired)) {
# Check if they're more than 1 observation per subject on each factor level
if (any(table(dt[["rowid"]], dt[[x]]) > 1)) {
stop("More than 1 observation per subject for at least one factor level, check your data with table()", call. = FALSE)
}
# Wide format - one row per subject and remove missing values
dt <- stats::na.omit(
object = data.table::dcast(
data = dt,
formula = stats::as.formula(
object = paste("rowid ~", x)
),
value.var = y
)
)[j = rowid := factor(x = rowid)][]
# Si el output solicitado es formato ancho devuelve el resultado intermedio
if (isTRUE(wide)) {
# Formato ancho
return(dt)
} else if (isFALSE(wide)) {
# De lo contrario en formato largo
dt <- data.table::melt(
data = dt,
id.vars = "rowid",
variable.name = x,
value.name = y
)
return(dt)
} else stop("`wide` must be TRUE or FALSE")
}
if (isTRUE(wide)) {
p <- function(i, lng) { i[!is.na(i)][seq_len(lng)] }
lng <- max(table(dt[[x]]), na.rm = TRUE)
# Formato ancho y no pareado
dt <- `attr<-`(
x = tapply(dt[[y]], dt[[x]], p, lng, simplify = FALSE),
which = "class",
value = c("data.table", "data.frame")
)
}
# Formato largo y no pareado
return(dt)
}
clean_data(
data = youngSwimmers::youngswimmers,
x = period,
y = weight,
rowid = subject,
paired = TRUE
)
clean_data <- function(data, x, y, rowid,
paired = FALSE,
wide = FALSE,
character.only = FALSE,
...) {
# Argument checking ---------------------------------------------------------------------------
# Check if `data` is null
if (missing(data)) stop("`data` can't be null", call. = FALSE)
# Check if `x` or `y` is null
if (missing(x) || missing(y)) stop("`x` and `y` can't be null", call. = FALSE)
# If `character.only` == FALSE, then NSE is used ----------------------------------------------
x <- rlang::ensym(x); y <- rlang::ensym(y)
# Check if variables are present in data ------------------------------------------------------
# Get names
colum_names <- names(data)
# Otherwise, check if is in data
if (all(x != colum_names) || all(y != colum_names)) stop("`x` and `y` must be within your data. Check your arguments", call. = FALSE)
# For latter use
x_var <- data[[x]]
# Check if rowid is present in the data if is paired and not null
if (isTRUE(paired)) {
if (missing(rowid)) {
rowid_var <- data.table::rowidv(x_var)
} else {
rowid <- rlang::ensym(rowid)
rowid_var <- data[[rowid]]
}
} else if (isFALSE(paired)) {
rowid_var <- NULL
} else stop("`paired` must be TRUE or FALSE")
# Add rowid if paired is TRUE and drop unused levels
dt <- data.table::data.table(x_var, data[[y]], rowid_var)
data.table::setnames(dt, 1:3, c(as.character(x), as.character(y), "rowid"))
dt <- droplevels(x = stats::na.omit(dt))
return(dt)
# Get levels for input data and output data
data_x_levels <- levels(data[[x]])
dt_x_levels <- levels(dt[[x]])
# Check for empty levels
if (length(data_x_levels) > length(dt_x_levels)) {
drlv <- data_x_levels[!data_x_levels %in% dt_x_levels]
# Display a warning if any
warning(
"Unused levels (i.e. ",
paste0(drlv, collapse = ", "),
") were dropped",
call. = FALSE
)
}
if (isTRUE(paired)) {
# Check if they're more than 1 observation per subject on each factor level
if (any(table(dt[["rowid"]], dt[[x]]) > 1)) {
stop("More than 1 observation per subject for at least one factor level, check your data with table()", call. = FALSE)
}
# Wide format - one row per subject and remove missing values
dt <- stats::na.omit(
object = data.table::dcast(
data = dt,
formula = stats::as.formula(
object = paste("rowid ~", x)
),
value.var = y
)
)[j = rowid := factor(x = rowid)][]
# Si el output solicitado es formato ancho devuelve el resultado intermedio
if (isTRUE(wide)) {
# Formato ancho
return(dt)
} else if (isFALSE(wide)) {
# De lo contrario en formato largo
dt <- data.table::melt(
data = dt,
id.vars = "rowid",
variable.name = x,
value.name = y
)
return(dt)
} else stop("`wide` must be TRUE or FALSE")
}
if (isTRUE(wide)) {
p <- function(i, lng) { i[!is.na(i)][seq_len(lng)] }
lng <- max(table(dt[[x]]), na.rm = TRUE)
# Formato ancho y no pareado
dt <- `attr<-`(
x = tapply(dt[[y]], dt[[x]], p, lng, simplify = FALSE),
which = "class",
value = c("data.table", "data.frame")
)
}
# Formato largo y no pareado
return(dt)
}
clean_data(
data = youngSwimmers::youngswimmers,
x = period,
y = weight,
rowid = subject,
paired = TRUE
)
clean_data <- function(data, x, y, rowid,
paired = FALSE,
wide = FALSE,
character.only = FALSE,
...) {
# Argument checking ---------------------------------------------------------------------------
# Check if `data` is null
if (missing(data)) stop("`data` can't be null", call. = FALSE)
# Check if `x` or `y` is null
if (missing(x) || missing(y)) stop("`x` and `y` can't be null", call. = FALSE)
# If `character.only` == FALSE, then NSE is used ----------------------------------------------
x <- rlang::ensym(x); y <- rlang::ensym(y)
# Check if variables are present in data ------------------------------------------------------
# Get names
colum_names <- names(data)
# Otherwise, check if is in data
if (all(x != colum_names) || all(y != colum_names)) stop("`x` and `y` must be within your data. Check your arguments", call. = FALSE)
# For latter use
x_var <- data[[x]]
# Check if rowid is present in the data if is paired and not null
if (isTRUE(paired)) {
if (missing(rowid)) {
rowid_var <- data.table::rowidv(x_var)
} else {
rowid <- rlang::ensym(rowid)
rowid_var <- data[[rowid]]
}
} else if (isFALSE(paired)) {
rowid_var <- NULL
} else stop("`paired` must be TRUE or FALSE")
# Add rowid if paired is TRUE and drop unused levels
dt <- data.table::data.table(x_var, data[[y]], rowid_var)
data.table::setnames(dt, 1:3, as.character(c(x, y, "rowid")))
dt <- droplevels(x = stats::na.omit(dt))
return(dt)
# Get levels for input data and output data
data_x_levels <- levels(data[[x]])
dt_x_levels <- levels(dt[[x]])
# Check for empty levels
if (length(data_x_levels) > length(dt_x_levels)) {
drlv <- data_x_levels[!data_x_levels %in% dt_x_levels]
# Display a warning if any
warning(
"Unused levels (i.e. ",
paste0(drlv, collapse = ", "),
") were dropped",
call. = FALSE
)
}
if (isTRUE(paired)) {
# Check if they're more than 1 observation per subject on each factor level
if (any(table(dt[["rowid"]], dt[[x]]) > 1)) {
stop("More than 1 observation per subject for at least one factor level, check your data with table()", call. = FALSE)
}
# Wide format - one row per subject and remove missing values
dt <- stats::na.omit(
object = data.table::dcast(
data = dt,
formula = stats::as.formula(
object = paste("rowid ~", x)
),
value.var = y
)
)[j = rowid := factor(x = rowid)][]
# Si el output solicitado es formato ancho devuelve el resultado intermedio
if (isTRUE(wide)) {
# Formato ancho
return(dt)
} else if (isFALSE(wide)) {
# De lo contrario en formato largo
dt <- data.table::melt(
data = dt,
id.vars = "rowid",
variable.name = x,
value.name = y
)
return(dt)
} else stop("`wide` must be TRUE or FALSE")
}
if (isTRUE(wide)) {
p <- function(i, lng) { i[!is.na(i)][seq_len(lng)] }
lng <- max(table(dt[[x]]), na.rm = TRUE)
# Formato ancho y no pareado
dt <- `attr<-`(
x = tapply(dt[[y]], dt[[x]], p, lng, simplify = FALSE),
which = "class",
value = c("data.table", "data.frame")
)
}
# Formato largo y no pareado
return(dt)
}
clean_data(
data = youngSwimmers::youngswimmers,
x = period,
y = weight,
rowid = subject,
paired = TRUE
)
clean_data <- function(data, x, y, rowid,
paired = FALSE,
wide = FALSE,
character.only = FALSE,
...) {
# Argument checking ---------------------------------------------------------------------------
# Check if `data` is null
if (missing(data)) stop("`data` can't be null", call. = FALSE)
# Check if `x` or `y` is null
if (missing(x) || missing(y)) stop("`x` and `y` can't be null", call. = FALSE)
# If `character.only` == FALSE, then NSE is used ----------------------------------------------
x <- rlang::ensym(x); y <- rlang::ensym(y)
# Check if variables are present in data ------------------------------------------------------
# Get names
colum_names <- names(data)
# Otherwise, check if is in data
if (all(x != colum_names) || all(y != colum_names)) stop("`x` and `y` must be within your data. Check your arguments", call. = FALSE)
# For latter use
x_var <- data[[x]]
# Check if rowid is present in the data if is paired and not null
if (isTRUE(paired)) {
if (missing(rowid)) {
rowid_var <- data.table::rowidv(x_var)
} else {
rowid <- rlang::ensym(rowid)
rowid_var <- data[[rowid]]
}
} else if (isFALSE(paired)) {
rowid_var <- NULL
} else stop("`paired` must be TRUE or FALSE")
# Add rowid if paired is TRUE and drop unused levels
dt <- data.table::data.table(x_var, data[[y]], rowid_var)
data.table::setnames(dt, 3:1, c("rowid", y ,x))
dt <- droplevels(x = stats::na.omit(dt))
return(dt)
# Get levels for input data and output data
data_x_levels <- levels(data[[x]])
dt_x_levels <- levels(dt[[x]])
# Check for empty levels
if (length(data_x_levels) > length(dt_x_levels)) {
drlv <- data_x_levels[!data_x_levels %in% dt_x_levels]
# Display a warning if any
warning(
"Unused levels (i.e. ",
paste0(drlv, collapse = ", "),
") were dropped",
call. = FALSE
)
}
if (isTRUE(paired)) {
# Check if they're more than 1 observation per subject on each factor level
if (any(table(dt[["rowid"]], dt[[x]]) > 1)) {
stop("More than 1 observation per subject for at least one factor level, check your data with table()", call. = FALSE)
}
# Wide format - one row per subject and remove missing values
dt <- stats::na.omit(
object = data.table::dcast(
data = dt,
formula = stats::as.formula(
object = paste("rowid ~", x)
),
value.var = y
)
)[j = rowid := factor(x = rowid)][]
# Si el output solicitado es formato ancho devuelve el resultado intermedio
if (isTRUE(wide)) {
# Formato ancho
return(dt)
} else if (isFALSE(wide)) {
# De lo contrario en formato largo
dt <- data.table::melt(
data = dt,
id.vars = "rowid",
variable.name = x,
value.name = y
)
return(dt)
} else stop("`wide` must be TRUE or FALSE")
}
if (isTRUE(wide)) {
p <- function(i, lng) { i[!is.na(i)][seq_len(lng)] }
lng <- max(table(dt[[x]]), na.rm = TRUE)
# Formato ancho y no pareado
dt <- `attr<-`(
x = tapply(dt[[y]], dt[[x]], p, lng, simplify = FALSE),
which = "class",
value = c("data.table", "data.frame")
)
}
# Formato largo y no pareado
return(dt)
}
clean_data(
data = youngSwimmers::youngswimmers,
x = period,
y = weight,
rowid = subject,
paired = TRUE
)
inherits(data, "data.table")
inherits
class()
class
data = youngSwimmers::youngswimmers
# paired: true;
data[, periodo]
# paired: true;
data[, period]
# paired: true;
data[, "period"]
# paired: true; no rowid
data[, weight, periodo]
# paired: true; no rowid
data[, weight, period]
library(data.table)
# paired: true; no rowid
data[, weight, .(period, rowid = rleid(periodo))]
# paired: true; no rowid
data[, weight, .(period, rowid = rleidv(periodo))]
# paired: true; no rowid
data[, weight, .(period, rowid = rleid(periodo))]
# paired: true; no rowid
data[, weight, .(period, rowid = rleid(period))]
# paired: true; no rowid
data[, weight, .(period, rowid = rleid(.N))]
# paired: true; no rowid
data[, weight, .(period, rowid = rleid(.I))]
# paired: true; no rowid
data[, weight, .(period, rowid = .I)]
# paired: true; no rowid
data[, weight, .(period, rowid = .NGRP)]
# paired: true; no rowid
data[, .(weight, rowid = seq_len(.N)), period]
# paired: true; no rowid
data[, .(rowid = seq_len(.N), weight), period]
# paired: true; no rowid
data[, .(weight), .(period, rowid = seq_len(.N))]
# paired: true; no rowid
data[, .(rowid = seq_len(.N), weight), period]
# paired: true; no rowid
data[, .(rowid = seq_len(.N), weight), droplevels(period)]
# paired: false; rowid
data[, weight, .(rowid = subject, period)]
# paired: false; rowid
data[, weight, .(period, rowid = subject)]
# paired: true; no rowid
data[, .(rowid = seq_len(.N), weight), period]
# paired: false; rowid
data[, weight, .(period, rowid = subject)]
# paired: false; rowid
data[j = weight,
by = .(period, rowid = subject)]
# paired: true; no rowid; long
data[
j = .(rowid = seq_len(.N), weight),
by = period
][
j = droplevels(.SD)
]
# paired: true; no rowid; long
data[
j = .(rowid = seq_len(.N), weight),
by = period
][
j = na.omit(.SD)
][
j = droplevels(.SD)
]
# paired: true; no rowid; long
data[, .(rowid = seq_len(.N), weight), period
][j = na.omit(.SD)
][j = droplevels(.SD)]
# paired: true; no rowid; long
data[, .(rowid = seq_len(.N), weight), period
][, na.omit(.SD)
][, droplevels(.SD)]
# paired: true; no rowid; wide
dcast(
data = data[, .(rowid = seq_len(.N), weight), period
][, na.omit(.SD)
][, droplevels(.SD)],
formula = period ~ rowid
)
# paired: true; no rowid; wide
dcast(
data = data[, .(rowid = seq_len(.N), weight), period
][, na.omit(.SD)
][, droplevels(.SD)],
formula =  rowid ~ period
)
# paired: true; no rowid; wide
dcast(
data = data[, .(rowid = seq_len(.N), weight), period],
formula =  rowid ~ period
)
# paired: true; no rowid; wide
dcast(data[, .(rowid = seq_len(.N), weight), period],
formula =  rowid ~ period)[, na.omit(.SD)]
# paired: true; no rowid; wide
dcast(data[, .(rowid = seq_len(.N), weight), period],
formula =  rowid ~ period)[, na.omit(.SD)][, droplevels(.SD)]
# paired: true; rowid; wide
dcast(data[, weight, .(period, rowid = subject)],
formula =  rowid ~ period
)[, na.omit(.SD)
][, droplevels(.SD)]
